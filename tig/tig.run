#!/usr/bin/env bash

lib.load devel

dir='/tmp/tig'
t=${dir}/tig.tag
b=${dir}/tig.branch
p=${dir}/tig.patch
m=${dir}/tig.commit
s=${dir}/tig.save
o=${dir}/tig.out

mkdir $dir 2>&-

cmd() { eval $@ &> $o; }
cmd.full() {
	local ret

	cmd $@
	ret=$?
    if (( $ret == 0 )); then
        echo "'$@' done"
    else
        echo "'$@' failed ($ret)"
    fi

	echo ""
	cat $o
}
cmd.file() {
	local ret file

	file="$1"; shift

	cmd $@; ret=$?
	cp -f $o $file

	return $ret
}

git.quiet() { cmd git $@; }
git.full() { cmd.full git $@; }
git.file() {
	local file

	file="$1"; shift
	cmd.full $file git $@
}

git.rcv() { git.full $@ || git $1 --abort; }

# is_commit <sha>
is_commit() { git rev-parse --verify --quiet ${1} &> /dev/null; }
# is_branch <branch>
is_branch() { git show-ref --verify --quiet refs/heads/${1} &> /dev/null; }
# is_tag <tag>
is_tag() { git show-ref --verify --quiet refs/tags/${1} &> /dev/null; }
# is_remote_branch <refname>
is_remote_branch() { git show-ref --verify --quiet refs/remotes/${1} &> /dev/null; }

# Convert SHA to branch
# 1. giving both SHA and branch would return the branch name on the SHA
# 2. giving SHA would return any branch name on the SHA
# check_branch <sha> [branch]
check_branch() {
	local branch rev

	if ! is_commit $1; then
		return 1
	fi

	if [[ -n "$2" ]]; then
		rev=$(git rev-parse $2 2>&- || echo "")
		if [[ "$1" == "$rev" ]]; then
			echo $2
		else
			false
		fi
		return
	fi

	for branch in $(git branch --format='%(refname:short)' | sed '/HEAD/d'); do
		rev=$(git rev-parse $branch)
		if [[ "$rev" == "$1" ]]; then
			echo $branch
			return
		fi
	done

	false
}

# Check remote branch
# get_remote_branch <branch>
get_remote_branch() {
	local remote

	if ! is_commit $1; then
		return 1
	fi

	remote=$(git rev-parse --abbrev-ref ${1}@{upstream} &> /dev/null)

	if [ -n "$remote" ]; then
		echo $remote
	else
		return 2
	fi
}

# Convert SHA to tag
# 1. giving both SHA and tag would return the tag name on the SHA
# 2. giving SHA would return any tag name on the SHA
# check_tag <sha> [tag]
check_tag() {
	local tag rev

	if ! is_commit $1; then
		return 1
	fi

	if [[ -n "$2" ]]; then
		rev=$(git rev-parse $2 2>&- || echo "")
		if [[ "$1" == "$rev" ]]; then
			echo $2
		else
			false
		fi
		return
	fi

	for tag in $(git tag -l); do
		rev=$(git rev-parse $tag)
		if [[ "$rev" == "$1" ]]; then
			echo $tag
			return
		fi
	done

	false
}

# To know which is the last action
# rebase/merge/am/revert/cherry-pick
_load_last_action() {
	local cmd
}

git.stash() {
	local repo="$(basename $(git rev-parse --show-toplevel))"
	local sha="$(git rev-parse --short HEAD)"

	git.quiet stash save ${1:-${repo}.${sha}}
}

# add <commit>
add() {
	if [[ -f $b ]]; then
		source $b
		git branch $branch $1
	elif [[ -f $t ]]; then
		source $t
		git tag $tag $1
	else
		echo "no assigned tag or branch"
	fi
	rm $t $b
}

# del <commit>,<branch>,<tag>
del() {
	local args raw

	IFS=',' read -ra raw <<< "$*"
	set -- "${raw[@]}"

	local tag=$(check_tag $1 $3)
	local branch=$(check_branch $1 $2)

	if [[ -n "$tag" ]]; then
		git tag -d $tag
		if [[ "$tag" =~ patch\.[0-9]+ ]]; then
			sed -i -e "/${1}/d" $p
			patch.refresh
			return
		fi
		echo "local tag=$tag" > $t
	else
		git branch -D $branch
		echo "local branch=$branch" > $b
	fi
}

# copy <text>
copy() {
	local cmd
	if type -f xclip > /dev/null; then
		cmd="xclip"
	elif type -f pbcopy > /dev/null; then
		cmd="pbcopy"
	else
		echo "no valid copy tools"; false
		return
	fi 2>&-

	echo -n "$@" | $cmd
	echo "copy '$@'"
}

# stage_file [file]
# - if [file] is empty, stage all files
stage_file() {
	if git diff --cached --quiet $1; then
		git add ${1:--u}
	else
		git reset --quiet HEAD $1
	fi
}

patch.refresh() {
	local i t p

	i=0
	for t in $(git tag -l | grep ^patch. | sort); do
		p="patch.$i"
		((i++))

		if [[ $t == $p ]]; then
			continue
		fi

		git tag $p $(git rev-parse $t)
		git tag -d $t
	done
}

patch.reset() {
	local file="$p"
	local item i

	i=100
	for item in $(cat $file); do
		git tag -d patch.$((i - 100))
		(( i++ ))
	done
	rm -f $file
}

patch.create() {
	local file="$p"
	local item i

	i=100
	for item in $(cat $file); do
		git format-patch --start-number $i -k --binary --histogram -1 -o . $item
		git tag -d patch.$((i - 100))
		(( i++ ))
	done &> /dev/null

	rm -f $file
	echo "$((i - 100)) patches has been created."
}

# patch.add <commit>
patch.add() {
	local file idx
	local commit

	commit="$1"
	file=$p
	touch $file

	idx=$(wc -l $file | cut -d' ' -f 1)
	if ! cat $file | grep -q $commit; then
		echo "select commit patch. ($commit)"
		git tag patch.${idx} $commit
		echo $commit >> $file
	else
		echo "same commit patch has been detected. ($commit)"
	fi
}

# push <commit>
# push -f <commit>
push() {
	local dst args

	source $s

	if [[ -z "$remote" ]]; then
		echo "no remote name"; false
		return
	fi

	if [[ -n "$branch" ]]; then
		dst="$branch"
	elif [[ -n "$tag" ]]; then
		dst="$tag"
	else
		echo "no remote branch or tag"; false
		return
	fi

	if [[ "$1" == '-f' ]]; then
		args="--force-with-lease"
		shift
	fi

	git.full push $args $remote ${1:-HEAD}:${dst}

	rm -rf $s
}

# push <branch|tag>
push.create() {
	source $s

	if [[ -z "$remote" ]]; then
		echo "no remote name"; false
		return
	fi

	if [[ -z "$1" ]]; then
		echo "Empty branch or tag name"; false
		return
	fi

	git.full push $remote $1

	rm -rf $s
}

# rebase <commit>
rebase() {
	local change

	change=$(git status --porcelain | grep -v '^??')
	if [[ -n "$change" ]]; then
		git stash
	fi

	git.full rebase $1
}

# save "<commit>,<branch>,<refname>,<tag>,<file>"
save() {
	local commit branch refname tag file
	local is_merged is_remote remote raw

	IFS=',' read -ra raw <<< "$*"
	set -- "${raw[@]}"
	commit="$1"
	branch="$2"
	refname="$3"
	tag="$4"
	file="$5"

	if [[ "$commit" =~ ^0+$ ]]; then
		commit=
		branch=
		tag=
	else
		if [[ $(git cat-file -p $commit | grep -c '^parent ') > 1 ]]; then
			is_merged=y
		fi

		#       tag: branch:'',   refname:tag,         tag:tag
		#  local br: branch:name, refname:name,        tag:''
		# remote br: branch:name, refname:origin/name, tag:''
		if [[ "$branch" == "$refname" ]]; then
			remote=''
			branch=$(check_branch $commit $branch)
		else
			is_remote=y
			remote="${refname%/$branch}"
		fi

		tag=$(check_tag $commit $tag)
	fi

	# check file
	if [[ -e "$file" ]]; then
		file=$file
	fi

	cat | tee $s <<-EOF
	# This is $([[ -z $is_merged ]] && echo "not ")merged commit
	is_merged=$is_merged

	# This is $([[ -z $is_remote ]] && echo "not ")remote branch
	is_remote=$is_remote

	# $(is_commit "${raw[0]}" || echo "un")committed
	commit=$commit

	# ${raw[1]:-<null>}: branch is $(check_branch ${raw[0]} ${raw[1]} || echo "incorrect")
	branch=$branch

	# ${raw[2]:-<null>}: remote is $(get_remote_branch ${raw[2]} || echo "non-existed")
	remote=$remote

	# ${raw[3]:-<null>}: tag is $(check_tag ${raw[0]} ${raw[3]} || echo "non-existed")
	tag=$tag

	# ${raw[4]:-<null>}: file is $([[ -e "${raw[4]}" ]] || echo "non-existed")
	file=$file
	EOF
}

clean() {
	echo "clean configurations"
	rm -f $s
}

progress() {
	local cmd bis
	for cmd in REBASE_HEAD MERGE_HEAD REVERT_HEAD CHERRY_PICK_HEAD; do
		if git rev-parse --verify $cmd &> /dev/null; then
			cmd=${cmd%%_HEAD}
			cmd=${cmd//_/-}
			cmd=${cmd~~}
			echo "'$cmd' is in progress"
			return
		fi
	done

	bis=$(git rev-parse --show-toplevel)/.git/BISECT_ANCESTORS_OK
	if [[ -e $bis ]]; then
		echo "'bisect' is in progress"
	fi

	echo "not in any git session"
}

abort() {
	local cmd bis
	for cmd in REBASE_HEAD MERGE_HEAD REVERT_HEAD CHERRY_PICK_HEAD; do
		if git rev-parse --verify $cmd &> /dev/null; then
			cmd=${cmd%%_HEAD}
			cmd=${cmd//_/-}
			cmd=${cmd~~}
			git.full $cmd --abort
			return
		fi
	done

	bis=$(git rev-parse --show-toplevel)/.git/BISECT_ANCESTORS_OK
	if [[ -e $bis ]]; then
		git.full bisect reset
	fi
}

going() {
	local cmd
	for cmd in REBASE_HEAD MERGE_HEAD REVERT_HEAD CHERRY_PICK_HEAD; do
		if git rev-parse --verify $cmd &> /dev/null; then
			cmd=${cmd%%_HEAD}
			cmd=${cmd//_/-}
			cmd=${cmd~~}
			git.full $cmd --continue
			return
		fi
	done
}

commit_report() {
	cat <<-EOF
	-- Commit Report --

	$(printf -- "Commit\tAuthor\n")
	EOF
	git shortlog --summary --numbered --all --no-merges
}

eval $@
