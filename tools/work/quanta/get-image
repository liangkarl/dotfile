#!/bin/bash
#
# Config file sample:
#   # required
#   remote='hogwarts'
#   remote_root=(
#   "path/one"
#   "path/two"
#   )
#   remote_out='final-images'
#
#   # optional
#   default_local_dir="images@$(date +%Y%m%d-%H%M%S)"
#   default_remote_files=(
#   "aaa.img"
#   "bbb.bin"
#   "ccc.xz"
#   )

usage() {
	cat << USAGE
Get images from remote server

Usage:
$(basename $0) [-s SourceFile] [-d TargetDir]
USAGE
}

search_config() {
	# search parent dir for image.conf
	local dir search conf

	# search image.conf
	dir=$(pwd)
	search='fd -t f -e conf -d 1 image'
	while [[ "$dir" != '/' ]]; do
		conf="$($search $dir)"
		if [[ ! -z "$conf" ]]; then
			echo ${conf}
			return 0
		fi

		dir="$(readlink -e $(dirname $dir) 2>&-)"
	done

	echo ""
	return 128
}

set -eE

# read default conf
conf="$(search_config)"
if [[ -z "$conf" ]]; then
	echo "failed to find config" >&2
else
	source $conf
fi

# no check for required variables, so don't mess them

# check optional variables
default_local_dir=${default_local_dir:-.}
if (( ${#default_remote_files[@]} == 0 )); then
	default_remote_files="*"
else
	default_remote_files="{${default_remote_files[@]}}"
	default_remote_files="${default_remote_files// /,}"
fi

# parse options
while (( $# != 0 )); do
	case $1 in
		-d)
			shift
			local_dir=$1
			;;
		-s)
			shift
			remote_file=$1
			;;
		*)
			usage
			exit 2
	esac
	shift
done

# print select menu & get answer
root=''
list_len=${#remote_root[@]}
if (( $list_len != 1 )); then
	PS3="Select an option from 1 to ${list_len}: "
	select item in "${remote_root[@]}"; do
		# $REPLY is what user entered
		# $item is limited in list values
		if [[ -z $item ]]; then
			echo "exit with '$REPLY'"
			exit 3
		fi
		root=$item
		echo "remote dir: $root"
		break
	done
else
	root="${remote_root[0]}"
fi

# assign customized parameters
argv='-'
argv+='a'	# shortcut of -r, -l, -p, -t, -g, -o, -D
			# recurise, link, preserve most file attributes
argv+='h'	# output human readable numbers
argv+='z'	# compress file data
argv+='v'	# verbose
argv+='u'	# only update modified data and skip no changed files
argv+='S'	# handle sparse files efficiently
argv+=' --progress'
			# show progress while transferring data
argv+=' --delete'
			# remove dst files not existed in src dir
argv+=' --partial-dir=.rsync-partial'
			# partial files can keep last download progess before interrupt
#argv+=' --inplace'
			# update dst files in-place instead of temp dir

# confirm dry-run result
out="$remote_out"
local_dir="${local_dir:-$default_local_dir}"
remote_file="${remote_file:-$default_remote_files}"
cmd="rsync -n ${argv} ${remote}:${root}/${out}/${remote_file} ${local_dir}/"
echo $cmd
eval $cmd
read -p "Is this dry-run result correct? (Y/n) " ans
if [[ "${ans,,}" == 'n' ]]; then
	echo "stop rsync" >&2
	exit 255
fi

# execute command
cmd="rsync ${argv} ${remote}:${root}/${out}/${remote_file} ${local_dir}/"
eval $cmd
