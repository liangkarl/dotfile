#!/usr/bin/env bash

source $(mylib io)

# set -xv
set -eE

usage() {
    local n

    n=$(basename $0)
    cat <<-EOF
	NAME:
	$n [-s start] [-e end] [-a tarball]

	OPTIONS:
	-s: start point of commit (generate patches)
	-e: end point of commit (generate patches)
	-a: apply patch from tarball
	EOF

    exit $1
}

apply() {
    local sha_list
	local p ans rev
    sha_list=$(mktemp)

    tar -xvf $1
	for p in $(repo list -p); do
		rev="$(git rev-parse HEAD)"

		cd $p
		[[ ! -e ${pout} ]] && continue

		echo "${rev},${p}" >> $sha_list
		git am -sk --ignore-whitespace ${pout}/* || {
			pr_err "recover working tree due to 'am' error. ($?)"
			git am --abort
			git reset --hard $rev
		}
		cd $OLDPWD
	done

    read -p "reset/clean to original HEAD? [Y/n] " ans
    [[ "${ans,,}" == n ]] && exit

	for p in $(repo list -p); do
		rev="$(cat $sha_list | awk -F, '/'${p}'/{print $1}')"

		cd $p
		[[ ! -e ${pout} ]] && continue
		[[ "$(git rev-parse HEAD)" == "$rev" ]] && continue

		git reset --hard $rev
		rm -rf $pout
		cd $OLDPWD
	done
}

# assume cwd is at the top directory of repo
generate() {
	local tmplist name
	local begin end
	local p

	begin="$1"
	end="$2"
	name=${end}_patchset.txz
	tmplist="$(mktemp)"
	trap "rm $tmplist" EXIT

	for p in $(repo list -p); do
		# if git sha is not available
		git rev-parse -q --verify ${begin} > /dev/null || {
			pr_err "skip '$p' for there is no '${begin}' in repository"
			continue
		}

		git -C ./$p format-patch --binary -k -o $pout ${begin}..${end}

		# remove empty directory
		rmdir ${p}/$pout || echo ${p}/$pout >> $tmplist
	done 2> /dev/null

	echo "compress patches into $name ..."
	tar -Jcvf $name $(<$tmplist)

	repo manifest -r -o "${begin,,}.xml"
}

pout='.patch'

(( $# == 0 )) && usage 1

while (( $# != 0 )); do
    case "$1" in
        -s) shift
            begin="$1"
            ;;
        -e) shift
            end="$1"
            ;;
        -a) shift
			[[ -e "$1" ]] || usage 3

            afile="$1"
            ;;
        *)
            usage 2
            ;;
    esac
    shift
done

# apply patches generated for repo projects
[[ ! -z "$afile" ]] && {
	apply $afile
	exit 0
}

# generate patches
[[ -z "$begin" ]] && usage 4
[[ -z "$end" ]] && end='HEAD'

generate $begin $end

pr_good "complete"
