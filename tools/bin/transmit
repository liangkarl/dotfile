#!/usr/bin/env bash

source $(mylib file)
source $(mylib io)
source $(mylib menu)

set -eE

export_conf() {
	cat > ${1}/${FCONF} <<-EOF
	# REQUIRED VARS
	remote=''
	remote_root=(
		"first"
		"second"
	)

	# OPTIONAL VARS
	# LDIR="images@$(date +%Y%m%d-%H%M%S)"
	# RFILES=(
	#	"aaa.img"
	#	"bbb.bin"
	#	"ccc.xz"
	# )
	# BIN='rsync'
	# SSHPASS_PWD=''
EOF
}

usage() {
	local name="$(basename $0)"

	cat <<-EOF
	NAME:
	$name - download/upload files from/to remote server

	SYNOPSIS:
	$name [-f UP/DOWN file] [-d UP/DOWN dir]
	$name [-o ouput-dir] [-b CopyTool]

	OPTIONS:
	    -x: debug
	    -u: upload file (default: download)
	    -f: copy the file from/to the other side.
	    -d: copy the file(s) from/to the directory. (default: .)
	    -b: change copy tool
	    -o: export sample config
	EOF

	exit $1
}

wait_and_join() {
	local num pnum
	local pid
	local sec
	local skip_sleep
	local run_names
	local cbol

	pnum="$1" # how many process needs to be waited?
	[[ -z $pnum ]] && return 1

	num=$(wc -l $plist | awk '{print $1}') # total process
	(( $num == 0 )) && return 0

	[[ $pnum == "all" ]] &&	pnum="$num"

	# Clear to beginning of line
	cbol="$(tput el1)"

	# keep scanning process list
	sec=0
	while (( pnum != 0 )); do
		run_names=""
		num=$(wc -l $plist | awk '{print $1}')
		(( $num == 0 )) && return 0

		skip_sleep=n
		# scan the list from line 1 to $num
		for i in $(seq -s ' ' 1 $num); do
			str="$(sed "${i}q;d" $plist)"
			pid=${str%%,*}
			name=${str#*,}
			# echo $str, $pid, $name

			if ! ps -h --pid $pid -o pid &> /dev/null; then
				# transmit process has exited
				printf '%s\rtransmit '%s' finished. (%d)\n' \
						"$cbol" $name, $pid
				sed -i -e "${i}d" $plist

				pnum=$((pnum - 1))
				sec=0
				skip_sleep=y

				break
			fi

			run_names+="$name "
		done

		[[ $skip_sleep == y ]] && continue

		# avoid busy loop
		sleep 1
		printf '%s\rwait [%s] finished. ( %d sec(s) )' \
				"$cbol" "${run_names}" $((sec++))
	done

	return 0
}

select_and_show_menu() {
	# print select menu & get answer
	local list_len

	# only one transmit position
	list_len=${#remote_root[@]}
	if (( $list_len == 1 )); then
		root="${remote_root[0]}"
		return 0
	fi

	# manual selection
	menu_title 'more than one site as below:'
	menu_prompt 'select one to continue'
	menu_default 1
	menu ${remote_root[@]}
	root=$(menu_final)

	echo "remote dir: $root"
}

# disable the glob (noglob)
set -f

# set default values
RFILES='*'
LDIR='.'
BIN='rsync'
FCONF='transmit.conf'
MAX_THREADS=4
DIRECTION=down
SSHPASS_PWD=''

declare -A CMD_OPTS
# -a, --archive: archive mode; equals -rlptgoD (no -H,-A,-X)
#                recurise, link, preserve most file attributes
# -h, --human-readable: output numbers in a human-readable format
# -z, --compress: compress file data during the transfer
# -v, --verbose: increase verbosity
# -q, --quiet: suppress non-error messages
# -u, --update: skip files that are newer on the receiver
# --progress: show progress during transfer
# --delete: delete extraneous files from dest dirs
# --inplace: update destination files in-place
# --stats: give some file-transfer stats
#
# incompatible with '--partial-dir' & '-S'
# -S, --sparse: handle sparse files efficiently
# --partial-dir=DIR: partial files can keep last download progess before interrupt
RSYNC_OPTS=('-a' '-h' '-z' '-u' '--delete' '--inplace' '-q' '--stats')
SFTP_OPTS=('-r' '-C')
SCP_OPTS=('-r' '-C')
CMD_OPTS=(
	[rsync]="${RSYNC_OPTS[@]}"
	[scp]="${SCP_OPTS[@]}"
	[sftp]="${SFTP_OPTS[@]}"
)

# parse options
while (( $# != 0 )); do
	case $1 in
		-x)
			DEBUG=y
			;;
		-u)
			DIRECTION=up
			;;
		-d)
			shift
			local_dir="$1"
			;;
		-f)
			shift
			src_files="$1"
			;;
		-b)
			shift
			bin="$1"
			;;
		-o)
			shift
			EXPORT_DIR="$1"
			;;
		*)
			usage 2
	esac
	shift
done

# check -x option
[[ "$DEBUG" == y ]] && set -xv

# check -o option
if [[ ! -z "$EXPORT_DIR" ]]; then
	if [[ -d "$EXPORT_DIR" ]]; then
		export_conf "$EXPORT_DIR"
		exit 0
	fi
	exit_msg 2 "invalid directory for exportion"
fi

# load .conf to override inner variables
FCONF="$(find_file_path $(pwd)/$FCONF || true)"
[[ -z "$FCONF" ]] && exit_msg 1 "failed to find config"

echo "load: ${FCONF}"
source $FCONF

# check runtime variables
[[ -z "$bin" ]] && bin=$BIN
[[ -z "$src_files" ]] && src_files=("${RFILES[@]}")
[[ -z "$local_dir" ]] && local_dir=$LDIR

# print select menu & get answer
select_and_show_menu

# setup_transmit_args
cmd=()
if [[ ! -z "$SSHPASS_PWD" ]]; then
	cmd+=('sshpass' '-p' "${SSHPASS_PWD}")
fi
cmd+=("$bin")
cmd+=("${CMD_OPTS[${bin}]}")

export plist="$(mktemp)"
export pidfile="$(mktemp)"

trap "rm -f $plist $pidfile" 0

[[ $DIRECTION == down && ! -d $local_dir ]] && mkdir -p $local_dir

num=0
echo "start parallel transmitting, direction: $DIRECTION, max thread: $MAX_THREADS"
for file in ${src_files[@]}; do
	# block threads if limit is reached
	if (( $num >= ${MAX_THREADS} )); then
		wait_and_join 1
		num=$((num - 1))
	fi

	# fork multiple threads to copy files
	if [[ $DIRECTION == 'down' ]]; then
		eval "${cmd[@]} ${remote}:${root}/${file} ${local_dir}/ &"
	else
		eval "${cmd[@]} ${local_dir}/${file} ${remote}:${root}/ &"
	fi

	# FIXME: don't know why we can't assign var via pipeline
	ps -h --ppid $BASHPID -o pid,cmd > $pidfile
	pid="$(cat $pidfile | grep $file | awk '{print $1}')"
	echo "start to transmit '$file' ($pid)"

	# if thread ended before we record it
	[[ -z $pid ]] && continue

	echo "$pid,$file" >> $plist

	num=$((num + 1))
done

# wait transmit threads join
wait_and_join all

# join finished
echo "all transmition has finished"
