#!/bin/bash

# MIT License
# -----------
# Copyright (c) 2021 Karl Liang
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the "Software"), to deal in the Software without
# restriction, including without limitation the rights to use,
# copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following
# conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
# OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.

import-script prints 2>&-
import-script files 2>&-

# don't move to botton since 'extglob' needs to be called at first
shopt -s extglob

usage() {
	local name
	name="${1:-$(basename $0 2>&-)}"

	cat<<-USAGE
	NAME:
	    $name - a helper script for MTK build system.

	SYNOPSIS:
	    $name [-k|k|kernel] [-v|v|vendor] [-s|s|system]
	    $name [-m|m|merge] [-mo|mo|merge-ota]

	DESCRIPTION:
	    k, v, s - compile kernel, vendor or system
	    m, o - generate whole images or otapackage.zip

	EXAMPLE:
	    # compile kernel, vendor, system and merge images
	    $ $name k v s m
	USAGE
}

split_build() {
	local split_build merged_dir
	local cmd out config

	for item in 'kernel' 'vendor' 'system'; do
		out="${item}_out_dir"
		config="${item}_lunch"
		if [[ -z "${!out}" ]]; then
			echo "get product out directory of ${item}"
			lunch ${!config}
			eval ${out}=$ANDROID_PRODUCT_OUT
		fi
	done

	merged_dir="$(readlink -f final-images)"
	split_build=$system_out_dir/images/split_build.py

	rm -rf $merged_dir
	cmd=$(trap -p ERR | awk -F\' '{print $2}')
	trap "${cmd}; rm -rf ${merged_dir}" ERR

	python $split_build \
		--system-dir $system_out_dir/images \
		--vendor-dir $vendor_out_dir/images \
		--kernel-dir $kernel_out_dir/images \
		--output-dir $merged_dir $1
}

build_kernel() {
	lunch $kernel_lunch
	kernel_out_dir=$ANDROID_PRODUCT_OUT
	rm -rf ${kernel_out_dir}/obj/KERNEL_OBJ
	rm -rf ${kernel_out_dir}/images/krn*
	make -j24 krn_images
	# FIXME: move cmd db feature to somewhere else
	# if [[ -e "$(readlink -e "$kernel_dir")" ]]; then
	# 	cmd_list+=("setup_kernel_cmddb $kernel_dir")
	# fi
}

build_system() {
	lunch $system_lunch
	system_out_dir=$ANDROID_PRODUCT_OUT

	rm -rf ${system_out_dir}/obj
	rm -rf ${system_out_dir}/images
	make -j24 sys_images
	# FIXME: move cmd db feature to somewhere else
	# cmd_list+=("create_cmd_db system")
}

build_vendor() {
	lunch $vendor_lunch
	vendor_out_dir=$ANDROID_PRODUCT_OUT

	# avoid to remove kernel obj with same config name
	rm -rf ${vendor_out_dir}/images/vnd*
	rm -rf ${vendor_out_dir}/obj/!(KERNEL_OBJ)
	make -j24 vnd_images
	# FIXME: move cmd db feature to somewhere else
	# cmd_list+=("create_cmd_db vendor")
}

show_info() {
	# global var: note, interval
	interval=$(($(date +%s) - ${interval}))

	# show consumed time
	echo ""
	echo "total consumed time: $(date -d@${interval} -u +%H:%M:%S)"

	# show build note
	if [[ -e "$note" ]]; then
		if [[ $(type -t mdv) == "file" ]]; then
			# with markdown render
			mdv $note
		else
			cat $note
		fi
		rm -f $tmp_note
	fi
}

draft_buildnote() {
	local tmp_note="$1"
	echo "# build-info" > $tmp_note
	echo "* build start: $(date '+%D - %T')" >> $tmp_note
	echo "* location: $(pwd)" >> $tmp_note
	echo "* commad: ${raw_cmd}" >> $tmp_note
	echo "" >> $tmp_note
	echo "# note" >> $tmp_note
}

# Global variables:
# kernel_lunch vendor_lunch system_lunch
# kernel_out_dir vendor_out_dir system_out_dir
# kernel_dir

declare -r envsetup_sh='build/envsetup.sh'
declare -i timer
declare cmd_list argv
declare raw_cmd

# export all functions
set -a
# exit on error
set -e
# make ERR trap inherit shell function
set -E
# return while meet unset variables
# set -u
# return error, once the first pipline command is failed
# set -o pipefail

# check input parameters
if (( $# == 0 )); then
	echo "no more actions"
	exit
fi
raw_cmd="$(basename $0) $@"

# check basic required command
if [[ "$(type -t lunch)" != "function" ]] &&
		! source $envsetup_sh 2>&-; then
	echo "no 'lunch' for execution" >&2
	exit 249
fi

# parse options
# change to flags, instead of command queue, to prevent ordering problems
while (( $# != 0 )); do
	argv="$1"
	case "$argv" in
		m|-m|merge)
			need_merge=y
			;;
		o|-o|ota)
			ota=y
			;;
		k|-k|kernel)
			make_kernel=y
			;;
		s|-s|system)
			make_system=y
			;;
		v|-v|vendor)
			make_vendor=y
			;;
		h|-h|help)
			usage
			exit
			;;
		*)
			usage
			exit 248
	esac
	shift
done

# show required build info automatically
trap 'show_info' EXIT
# show failed command while occurring error
cmd='$BASH_SOURCE:$LINENO $BASH_COMMAND'
trap "pr_err 'last cmd: ${cmd}'" ERR
# start counter
interval=$(date +%s)

old_note=".buildnote.md.old"
tmp_note="buildnote.tmp"
note="buildnote.md"

# write necessary notes
draft_buildnote $tmp_note

# preview buildnote
mdv $note

# select write method
num=1
for item in 'add-note' 'skip' 'exit'; do
	echo "$((num++))) ${item}"
done
msg="select an option to create build note: "
read -p "$msg" option

case ${option:-1} in
	1|"add-note") # new build note
		if [[ -e "$note" ]]; then
			# restore old notes
			cat $note | awk '/^# note$/ {show=1; line=NR}
					show == 1 && NR >line {print $0}' >> $tmp_note
		else
			# new line for new notes
			echo "" >> $tmp_note
		fi
		# go to end of file
		vim "+$" $tmp_note

		if [[ -e "$note" ]]; then
			mv $note $old_note
		fi
		mv $tmp_note $note
		;;
	2|"skip") # no needs for build note
		echo "use default build note"
		if [[ -e "$note" ]]; then
			# restore old notes
			cat $note | awk '/^# note$/ {show=1; line=NR}
					show == 1 && NR >line {print $0}' >> $tmp_note
		fi

		# Don't override old build note
		# Replace latest note only
		mv $tmp_note $note
		;;
	3|"exit")
		exit
		;;
	*)
		cmd="invalid option: '${option}'"
		false
		;;
esac

# start compiling
if [[ "${make_kernel}" == y ]]; then
	build_kernel
fi
if [[ "${make_vendor}" == y ]]; then
	build_vendor
fi
if [[ "${make_system}" == y ]]; then
	build_system
fi
if [[ "${need_merge}" == y ]]; then
	if [[ "${ota}" == y ]]; then
		split_build --otapackage
	else
		split_build
	fi
fi
