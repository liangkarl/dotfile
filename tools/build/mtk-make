#!/bin/bash

# MIT License
# -----------
# Copyright (c) 2021 Karl Liang
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the "Software"), to deal in the Software without
# restriction, including without limitation the rights to use,
# copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following
# conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
# OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.

import-script prints 2>&-
import-script files 2>&-

# don't move to botton since 'extglob' needs to be called at first
shopt -s extglob

usage() {
	local name
	name="${1:-$(basename $0 2>&-)}"

	cat<<-USAGE
	NAME:
	    $name - a helper script for MTK build system.

	SYNOPSIS:
	    $name [-k|k|kernel] [-v|v|vendor] [-s|s|system]
	    $name [-m|m|merge] [-mo|mo|merge-ota]

	DESCRIPTION:
	    k, v, s - compile kernel, vendor or system
	    m, o - generate whole images or otapackage.zip

	EXAMPLE:
	    # compile kernel, vendor, system and merge images
	    $ $name k v s m
	USAGE
}

split_build() {
	local split_build merged_dir
	local cmd out config

	for item in 'kernel' 'vendor' 'system'; do
		out="${item}_out_dir"
		config="${item}_lunch"
		if [[ -z "${!out}" ]]; then
			echo "get product out directory of ${item}"
			lunch ${!config}
			eval ${out}=$ANDROID_PRODUCT_OUT
		fi
	done

	merged_dir="$(readlink -f final-images)"
	split_build=$system_out_dir/images/split_build.py

	rm -rf $merged_dir
	cmd=$(trap -p ERR | awk -F\' '{print $2}')
	trap "${cmd}; rm -rf ${merged_dir}" ERR

	python $split_build \
		--system-dir $system_out_dir/images \
		--vendor-dir $vendor_out_dir/images \
		--kernel-dir $kernel_out_dir/images \
		--output-dir $merged_dir $1
}

build_kernel() {
	lunch $kernel_lunch
	kernel_out_dir=$ANDROID_PRODUCT_OUT
	rm -rf ${kernel_out_dir}/obj/KERNEL_OBJ
	rm -rf ${kernel_out_dir}/images/krn*
	make -j24 krn_images
	# FIXME: move cmd db feature to somewhere else
	# if [[ -e "$(readlink -e "$kernel_dir")" ]]; then
	# 	cmd_list+=("setup_kernel_cmddb $kernel_dir")
	# fi
}

build_system() {
	lunch $system_lunch
	system_out_dir=$ANDROID_PRODUCT_OUT

	rm -rf ${system_out_dir}/obj
	rm -rf ${system_out_dir}/images
	make -j24 sys_images
	# FIXME: move cmd db feature to somewhere else
	# cmd_list+=("create_cmd_db system")
}

build_vendor() {
	lunch $vendor_lunch
	vendor_out_dir=$ANDROID_PRODUCT_OUT

	# avoid to remove kernel obj with same config name
	rm -rf ${vendor_out_dir}/images/vnd*
	rm -rf ${vendor_out_dir}/obj/!(KERNEL_OBJ)
	make -j24 vnd_images
	# FIXME: move cmd db feature to somewhere else
	# cmd_list+=("create_cmd_db vendor")
}

add_build_note_header() {
	cat > $NOTE_HEADER <<-EOF
	# build-info
	* start: $(date '+%D - %T')
	* location: $(pwd)
	* commad: ${EXE_CMD}

	# environment
	* kernel_lunch=${kernel_lunch}
	* vendor_lunch=${vendor_lunch}
	* system_lunch=${system_lunch}

	# note
	EOF
}

add_build_note_content_exp() {
	cat > $NOTE_CONTENT <<-EOF
	[//]: # (Add items with Markdown syntax)
	[//]: # (sorted list: 1., 2.)
	[//]: # (unsorted list: *)
	EOF
}

parse_options() {
	# check input parameters
	if (( $# == 0 )); then
		echo "no more actions"
		exit
	fi

	while (( $# != 0 )); do
		case "$1" in
			m|-m|merge)
				NEED_MERGE=y
				TARGET_FILES=y
				;;
			o|-o|ota)
				NEED_MERGE=y
				OTA=y
				;;
			k|-k|kernel)
				MAKE_KERNEL=y
				;;
			s|-s|system)
				MAKE_SYSTEM=y
				;;
			v|-v|vendor)
				MAKE_VENDOR=y
				;;
			h|-h|help)
				usage
				exit
				;;
			*)
				usage
				exit 248
		esac
		shift
	done
}

add_build_note_content() {
	local i dopt list

	# select write method
	dopt=2
	list=('add-note' 'skip' 'exit')
	echo "Select an option to create build note:"
	for((i = 0; i < ${#list[@]}; i++)); do
		echo "$((i + 1))) ${list[$i]}"
	done
	read -p "> ($dopt) " option

	case ${option:-$dopt} in
		1|"add-note")
			if [[ ! -e $NOTE_CONTENT ]]; then # new note
				add_build_note_content_exp
			fi
			# go to end of file
			vim "+$" $NOTE_CONTENT
			;;
		2|"skip") # no needs for build note
			;;
		3|"exit")
			exit
			;;
		*)
			pr_err "invalid option: '${option}'"
			exit
			;;
	esac
}

err_act() {
	# substitute variable
	eval pr_err "$ERR_MSG"
	eval $ERR_ACT
}

exit_act() {
	# calculate build elapse time
	BUILD_TIME=$(($(date +%s) - ${BUILD_TIME}))

	# show consumed time
	echo -e "\ntotal consumed time: $(date -d@${BUILD_TIME} -u +%H:%M:%S)"

	# show build note
	mdv $NOTE
	eval $EXIT_ACT
}

build_code() {
	local args=()

	# start counter
	BUILD_TIME=$(date +%s)

	# show required build info automatically
	trap 'exit_act' EXIT
	trap 'err_act' ERR


	if [[ "${MAKE_KERNEL}" == y ]]; then
		build_kernel
	fi
	if [[ "${MAKE_VENDOR}" == y ]]; then
		build_vendor
	fi
	if [[ "${MAKE_SYSTEM}" == y ]]; then
		build_system
	fi
	if [[ "${NEED_MERGE}" == y ]]; then
		if [[ "${OTA}" == y ]]; then
			args+=('--otapackage')
		fi
		if [[ "${TARGET_FILES}" == y ]]; then
			args+=('--targetfiles')
		fi
		eval split_build ${args[@]}
	fi
}

# Global variables:
## Program variables
ENVSETUP='build/envsetup.sh'
EXE_CMD="$(basename $0) $@"
ERR_MSG='last command: $BASH_SOURCE:$LINENO $BASH_COMMAND'
ERR_ACT=''
BUILD_TIME=''
EXIT_ACT=''
NOTE_HEADER='.note.header'
NOTE_CONTENT='.note.text'
NOTE="buildnote.md"

## Compiliant flags:
MAKE_KERNEL=''
MAKE_VENDOR=''
MAKE_SYSTEM=''
NEED_MERGE=''
OTA=''

## Config variables:
# kernel_lunch vendor_lunch system_lunch
# kernel_out_dir vendor_out_dir system_out_dir
# kernel_dir

# export all functions
set -a
# exit on error
set -e
# make ERR trap inherit shell function
set -E
# return while meet unset variables
# set -u
# return error, once the first pipline command is failed
# set -o pipefail

# check basic required command
if [[ "$(type -t lunch)" != "function" ]] &&
		! source $ENVSETUP 2>&-; then
	echo "no 'lunch' for execution" >&2
	exit 249
fi

# parse options
# change to flags, instead of command queue, to prevent ordering problems
# parse_options
parse_options $@

# preview previous note
if [[ -e "${NOTE}" ]]; then
	cat <<-PREV
	=== last $NOTE preview ===
	$(mdv $NOTE)
	==========================
	PREV
else
	echo "no ${NOTE} for previewing"
fi

# edit build note
add_build_note_content

# write necessary notes
add_build_note_header

# merge header & content
cat $NOTE_HEADER $NOTE_CONTENT > $NOTE

# start compiling
build_code
