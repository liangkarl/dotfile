#!/bin/bash
#
# Config file sample:
#   # required
#   remote='hogwarts'		# can be 'user@host'
#   remote_root=(
#   "path/one"
#   "path/two"
#   )
#
#   # optional
#   local_dir="images@$(date +%Y%m%d-%H%M%S)"
#   remote_files=(
#   "aaa.img"
#   "bbb.bin"
#   "ccc.xz"
#   )
#   copy='rsync'

usage() {
	local name="$(basename $0)"
	cat <<-USAGE
	NAME:
	$name - Get images from remote server

	SYNOPSIS:
	$name [-s SrcFile] [-d DestDir] [-t] [-b CopyTool]

	OPTIONS:
	    -s: copy from remote source file.
	    -d: copy to dest directory. copy to '.' if no config
	        and variable assigned
	    -t: copy to 'temp/' under current dir
	    -b: change copy tool
USAGE
}

set -eE

# set default values
remote="${USER}@127.0.0.1"
remote_root=('null')
copy='rsync'
local_dir='.'
remote_files='*'
conf='image.conf'
sshpass_en=y
PASSWD=123

# read default conf
conf="$(search_file_upward $conf $(pwd) || true)"
if [[ -z "$conf" ]]; then
	echo "failed to find config" >&2
else
	echo "load: ${conf}"
	source $conf
fi

# parse options
while (( $# != 0 )); do
	case $1 in
		-x)
			DEBUG=y
			;;
		-d)
			shift
			local_dir=$1
			;;
		-s)
			shift
			remote_files=$1
			;;
		-t)
			local_dir='temp'
			;;
		-b)
			shift
			copy="$1"
			;;
		*)
			usage
			exit 2
	esac
	shift
done

[[ "$DEBUG" == y ]] && set -xv

# print select menu & get answer
root=''
list_len=${#remote_root[@]}
if (( $list_len != 1 )); then
	PS3="Select an option from 1 to ${list_len}: "
	select item in "${remote_root[@]}"; do
		# $REPLY is what user entered
		# $item is limited in list values
		if [[ -z $item ]]; then
			echo "exit with '$REPLY'"
			exit 3
		fi
		root=$item
		echo "remote dir: $root"
		break
	done
else
	root="${remote_root[0]}"
fi

argv=()
if [[ $copy == 'rsync' ]]; then
	# -a, --archive: archive mode; equals -rlptgoD (no -H,-A,-X)
	#                recurise, link, preserve most file attributes
	# -h, --human-readable: output numbers in a human-readable format
	# -z, --compress: compress file data during the transfer
	# -v, --verbose: increase verbosity
	# -q, --quiet: suppress non-error messages
	# -u, --update: skip files that are newer on the receiver
	# --progress: show progress during transfer
	# --delete: delete extraneous files from dest dirs
	# --inplace: update destination files in-place
	# --stats: give some file-transfer stats
	#
	# incompatible with '--partial-dir' & '-S'
	# -S, --sparse: handle sparse files efficiently
	# --partial-dir=DIR: partial files can keep last download progess before interrupt
	argv+=('-a' '-h' '-z' '-u')
	argv+=('--delete' '--inplace')
	argv+=('-q' '--stats')
elif [[ $copy == 'scp' ]] || [[ $copy == 'sftp' ]]; then
	argv+=('-r' '-C')
fi

if [[ "$sshpass_en" == 'y' ]]; then
	[[ -z "$PASSWD" ]] && {
		echo "null password for sshpass"
		exit 2
	}
	copy="sshpass -p $PASSWD $copy"
fi

for file in ${remote_files[@]}; do
	($copy ${argv[@]} ${remote}:${root}/${file} ${local_dir}/ &)
done
