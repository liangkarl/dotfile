#!/bin/bash -eE

export_conf() {
	cat > ${1}/${FCONF} <<-EOF
	# REQUIRED VARS
	remote=''
	remote_root=(
		"first"
		"second"
	)

	# OPTIONAL VARS
	# local_dir="images@$(date +%Y%m%d-%H%M%S)"
	# remote_files=(
	#	"aaa.img"
	#	"bbb.bin"
	#	"ccc.xz"
	# )
	# bin='rsync'
	# sshpass_pwd=''
EOF
}

usage() {
	local name="$(basename $0)"
	cat <<-USAGE
	NAME:
	$name - Get images from remote server

	SYNOPSIS:
	$name [-s SrcFile] [-d DestDir] [-t] [-b CopyTool]

	OPTIONS:
	    -s: copy from remote source file.
	    -d: copy to dest directory. copy to '.' if no config
	        and variable assigned
	    -t: copy to 'temp/' under current dir
	    -b: change copy tool
USAGE
}

wait_and_join() {
	local num pnum
	local pid
	local sec
	local skip_sleep

	pnum="$1" # how many process needs to be waited?
	[[ -z $pnum ]] && return 1

	num=$(wc -l $plist | awk '{print $1}') # total process
	(( $num == 0 )) && return 0

	[[ $pnum == "all" ]] &&	pnum="$num"

	# keep scanning process list
	sec=0;
	while (( pnum != 0 )); do
		num=$(wc -l $plist | awk '{print $1}')
		(( $num == 0 )) && return 0

		skip_sleep=n
		# scan the list from line 1 to $num
		for i in $(seq -s ' ' 1 $num); do
			str="$(sed "${i}q;d" $plist)"
			pid=${str%%,*}
			name=${str#*,}
			# echo $str, $pid, $name

			if ! ps -h --pid $pid -o pid &> /dev/null; then
				# download process has exited
				echo "download '$name' finished. (${pid})"
				sed -i -e "${i}d" $plist
				pnum=$((pnum - 1))
				skip_sleep=y
				break
			fi
		done

		[[ $skip_sleep == y ]] && continue

		# avoid busy loop
		sleep 1
		printf "wait $num downloading job(s) done. ( %d sec(s) )\r" $((sec++))
	done

	return 0
}

select_and_show_menu() {
	# print select menu & get answer
	local list_len

	# only one download position
	list_len=${#remote_root[@]}
	if (( $list_len == 1 )); then
		root="${remote_root[0]}"
		return 0
	fi

	# manual selection
	PS3="select an option from 1 to ${list_len}: "
	select item in "${remote_root[@]}"; do
		root=$item
		echo "remote dir: $root"
		return 0
	done
}

# set default values
RFILES='*'
LDIR='.'
BIN='rsync'
FCONF='image.conf'
PASSWD=123
SSHPASS_EN=y
MAX_THREADS=4

declare -A CMD_OPTS
# -a, --archive: archive mode; equals -rlptgoD (no -H,-A,-X)
#                recurise, link, preserve most file attributes
# -h, --human-readable: output numbers in a human-readable format
# -z, --compress: compress file data during the transfer
# -v, --verbose: increase verbosity
# -q, --quiet: suppress non-error messages
# -u, --update: skip files that are newer on the receiver
# --progress: show progress during transfer
# --delete: delete extraneous files from dest dirs
# --inplace: update destination files in-place
# --stats: give some file-transfer stats
#
# incompatible with '--partial-dir' & '-S'
# -S, --sparse: handle sparse files efficiently
# --partial-dir=DIR: partial files can keep last download progess before interrupt
RSYNC_OPTS=('-a' '-h' '-z' '-u' '--delete' '--inplace' '-q' '--stats')
SFTP_OPTS=('-r' '-C')
SCP_OPTS=('-r' '-C')
SSHPASS_OPTS=('-p' "$PASSWD")
CMD_OPTS=(
	[rsync]="${RSYNC_OPTS[@]}"
	[scp]="${SCP_OPTS[@]}"
	[sftp]="${SFTP_OPTS[@]}"
	[sshpass]="${SSHPASS_OPTS[@]}"
)

# parse options
while (( $# != 0 )); do
	case $1 in
		-x)
			DEBUG=y
			;;
		-d)
			shift
			local_dir="$1"
			;;
		-s)
			shift
			remote_files="$1"
			;;
		-t)
			local_dir='temp'
			;;
		-b)
			shift
			bin="$1"
			;;
		-o)
			shift
			EXPORT_DIR="$1"
			;;
		*)
			usage
			exit 2
	esac
	shift
done

[[ "$DEBUG" == y ]] && set -xv
if [[ ! -z "$EXPORT_DIR" ]]; then
	if [[ -d "$EXPORT_DIR" ]]; then
		export_conf "$EXPORT_DIR"
		exit 0
	fi
	echo "invalid directory for exportion"
	exit 2
fi

[[ -z "$bin" ]] && bin=$BIN
[[ -z "$remote_files" ]] && remote_files=$RFILES
[[ -z "$local_dir" ]] && local_dir=$LDIR

# read default conf
# FIXME:
# You need to clarify the difference bewteen conf & runtime vars.
FCONF="$(search_file_upward $FCONF $(pwd) || true)"
if [[ -z "$FCONF" ]]; then
	echo "failed to find config" >&2
	exit 1
fi

echo "load: ${FCONF}"
source $FCONF

# print select menu & get answer
select_and_show_menu

# setup_download_args
cmd=()
if [[ "$SSHPASS_EN" == y ]]; then
	cmd+=('sshpass')
	cmd+=("${CMD_OPTS[sshpass]}")
fi
cmd+=("$bin")
cmd+=("${CMD_OPTS[${bin}]}")

export plist="$(mktemp)"
export pidfile="$(mktemp)"

trap "rm -f $plist $pidfile" 0

[[ ! -d $local_dir ]] && mkdir -p $local_dir

num=0
for file in ${remote_files[@]}; do
	# block threads if limit is reached
	if (( $num >= ${MAX_THREADS} )); then
		wait_and_join 1
		num=$((num - 1))
	fi

	# fork multiple threads to copy files
	eval "${cmd[@]} ${remote}:${root}/${file} ${local_dir}/ &"

	# FIXME: don't know why we can't assign var via pipeline
	ps -h --ppid $BASHPID -o pid,cmd > $pidfile
	pid="$(cat $pidfile | grep $file | awk '{print $1}')"
	echo "start to download '$file' ($pid)"

	# if thread ended before we record it
	[[ -z $pid ]] && continue

	echo "$pid,$file" >> $plist

	num=$((num + 1))
done

# wait download threads join
wait_and_join all

# join finished
echo "all download has finished"
