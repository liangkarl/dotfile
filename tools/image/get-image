#!/bin/bash -eE
#
# Config file sample:
#   # required
#   remote='hogwarts'		# can be 'user@host'
#   remote_root=(
#   "path/one"
#   "path/two"
#   )
#
#   # optional
#   local_dir="images@$(date +%Y%m%d-%H%M%S)"
#   remote_files=(
#   "aaa.img"
#   "bbb.bin"
#   "ccc.xz"
#   )
#   copy='rsync'

usage() {
	local name="$(basename $0)"
	cat <<-USAGE
	NAME:
	$name - Get images from remote server

	SYNOPSIS:
	$name [-s SrcFile] [-d DestDir] [-t] [-b CopyTool]

	OPTIONS:
	    -s: copy from remote source file.
	    -d: copy to dest directory. copy to '.' if no config
	        and variable assigned
	    -t: copy to 'temp/' under current dir
	    -b: change copy tool
USAGE
}

wait_and_join() {
	local num
	num=$(wc -l $plist)

	while true; do
		# keep scaning process list
		for i in {1..$num}; do
			str="$(sed -i -e "${i}q;d" $plist)"
			pid=${str%%,*}
			name=${str#*,}
			echo $str, $pid, $name
			if ! ps -h --pid $pid -o pid= &> /dev/null; then
				# download process has exited
				echo "download '$name' finished"
				sed -i -e "${i}d" $plist
				return 0
			fi
		done
	done
}

# set default values
remote="${USER}@127.0.0.1"
remote_root=('null')
copy='rsync'
local_dir='.'
remote_files='*'
conf='image.conf'
sshpass_en=y
PASSWD=123

# read default conf
conf="$(search_file_upward $conf $(pwd) || true)"
if [[ -z "$conf" ]]; then
	echo "failed to find config" >&2
else
	echo "load: ${conf}"
	source $conf
fi

# parse options
while (( $# != 0 )); do
	case $1 in
		-x)
			DEBUG=y
			;;
		-d)
			shift
			local_dir=$1
			;;
		-s)
			shift
			remote_files=$1
			;;
		-t)
			local_dir='temp'
			;;
		-b)
			shift
			copy="$1"
			;;
		*)
			usage
			exit 2
	esac
	shift
done

[[ "$DEBUG" == y ]] && set -xv

# print select menu & get answer
root=''
list_len=${#remote_root[@]}
if (( $list_len != 1 )); then
	PS3="Select an option from 1 to ${list_len}: "
	select item in "${remote_root[@]}"; do
		# $REPLY is what user entered
		# $item is limited in list values
		if [[ -z $item ]]; then
			echo "exit with '$REPLY'"
			exit 3
		fi
		root=$item
		echo "remote dir: $root"
		break
	done
else
	root="${remote_root[0]}"
fi

argv=()
if [[ $copy == 'rsync' ]]; then
	# -a, --archive: archive mode; equals -rlptgoD (no -H,-A,-X)
	#                recurise, link, preserve most file attributes
	# -h, --human-readable: output numbers in a human-readable format
	# -z, --compress: compress file data during the transfer
	# -v, --verbose: increase verbosity
	# -q, --quiet: suppress non-error messages
	# -u, --update: skip files that are newer on the receiver
	# --progress: show progress during transfer
	# --delete: delete extraneous files from dest dirs
	# --inplace: update destination files in-place
	# --stats: give some file-transfer stats
	#
	# incompatible with '--partial-dir' & '-S'
	# -S, --sparse: handle sparse files efficiently
	# --partial-dir=DIR: partial files can keep last download progess before interrupt
	argv+=('-a' '-h' '-z' '-u')
	argv+=('--delete' '--inplace')
	argv+=('-q' '--stats')
elif [[ $copy == 'scp' ]] || [[ $copy == 'sftp' ]]; then
	argv+=('-r' '-C')
fi

if [[ "$sshpass_en" == 'y' ]]; then
	[[ -z "$PASSWD" ]] && {
		echo "null password for sshpass"
		exit 2
	}
	copy="sshpass -p $PASSWD $copy"
fi

export plist="$(mktemp)"
export pidfile="$(mktemp)"

trap "rm -f $plist $pidfile" 0

[[ ! -d $local_dir ]] && mkdir -p $local_dir

max=4
num=0
for file in ${remote_files[@]}; do
	# block threads if limit is reached
	if (( $num >= $max )); then
		wait_and_join
		num=$((num - 1))
	fi

	# fork multiple threads to copy files
	eval "$copy ${argv[@]} ${remote}:${root}/${file} ${local_dir}/ &"
	echo "begin to transfer '$file'"

	# FIXME: don't know why we can't assign var via pipeline
	ps -h --ppid $BASHPID -o pid= > $pidfile
	pid="$(cat $pidfile | head -1)"

	# if thread ended before we record it
	[[ -z $pid ]] && continue

	echo "$pid,$file" >> $plist

	num=$((num + 1))
done

# wait download threads join
while true; do
	[[ -z "$(<${plist})" ]] && break

	str="$(head -1 $plist)"
	pid=${str%%,*}
	name=${str#*,}

	echo "wait $name finished... (${pid})"
	wait -n $pid

	# download process has exited
	sed -i -e '1d' $plist
	echo "download '$name' finished"
done

# join finished
echo "all download has finished"
